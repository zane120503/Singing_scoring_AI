#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Optimized Audio Processor - Workflow t·ªëi ∆∞u h√≥a ƒë·ªÉ gi·∫£m th·ªùi gian x·ª≠ l√Ω
"""

import os
import sys
import logging
from pathlib import Path
from typing import Dict, Tuple, Optional
import numpy as np

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

from ai.voice_activity_detector import VoiceActivityDetector
from ai.advanced_voice_detector import AdvancedVoiceDetector
from ai.smart_voice_detector import SmartVoiceDetector
from ai.improved_smart_voice_detector import ImprovedSmartVoiceDetector
from ai.final_voice_detector import FinalVoiceDetector
from ai.correct_voice_detector import CorrectVoiceDetector
from ai.advanced_audio_processor import AdvancedAudioProcessor
from ai.advanced_key_detector import AdvancedKeyDetector
from core.scoring_system import KaraokeScoringSystem

logger = logging.getLogger(__name__)

class OptimizedAudioProcessor:
    """Optimized Audio Processor v·ªõi workflow t·ªëi ∆∞u h√≥a"""
    
    def __init__(self, sr: int = 22050):
        self.sr = sr
        
        # Kh·ªüi t·∫°o c√°c components
        self.vad = VoiceActivityDetector(sr)
        self.advanced_vad = AdvancedVoiceDetector(sr)  # Advanced VAD
        self.smart_vad = SmartVoiceDetector(sr)  # Smart VAD
        self.improved_smart_vad = ImprovedSmartVoiceDetector(sr)  # Improved Smart VAD
        self.final_vad = FinalVoiceDetector(sr)  # Final VAD
        self.correct_vad = CorrectVoiceDetector(sr)  # Correct VAD
        self.audio_processor = AdvancedAudioProcessor(fast_mode=False)
        self.key_detector = AdvancedKeyDetector()
        self.scoring_system = KaraokeScoringSystem()
        
        # C·∫•u h√¨nh
        self.min_voice_duration = 1.0  # T·ªëi thi·ªÉu 1 gi√¢y c√≥ gi·ªçng
        
        logger.info("‚úÖ Optimized Audio Processor initialized")
    
    def process_karaoke_optimized(self, 
                                karaoke_file: str, 
                                beat_file: str,
                                output_dir: str = None) -> Dict:
        """
        X·ª≠ l√Ω karaoke v·ªõi workflow t·ªëi ∆∞u h√≥a
        
        Args:
            karaoke_file: ƒê∆∞·ªùng d·∫´n file karaoke
            beat_file: ƒê∆∞·ªùng d·∫´n file beat nh·∫°c
            output_dir: Th∆∞ m·ª•c output (t√πy ch·ªçn)
            
        Returns:
            Dict: K·∫øt qu·∫£ x·ª≠ l√Ω ho√†n ch·ªânh
        """
        try:
            logger.info("üé§ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω karaoke v·ªõi workflow t·ªëi ∆∞u h√≥a...")
            
            # T·∫°o output directory n·∫øu ch∆∞a c√≥ (∆∞u ti√™n clean_song_output)
            if output_dir is None:
                output_dir = os.path.join(os.path.dirname(__file__), '..', '..', 'Audio_separator_ui', 'clean_song_output')
            os.makedirs(output_dir, exist_ok=True)
            
            # B∆∞·ªõc 1: Voice Activity Detection (Correct)
            logger.info("üîç B∆∞·ªõc 1: Ph√°t hi·ªán voice activity v·ªõi Correct VAD...")
            voice_segments = self.correct_vad.detect_voice_activity(karaoke_file)
            
            if not voice_segments:
                return {
                    "success": False,
                    "error": "Kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c gi·ªçng h√°t trong file karaoke",
                    "step": "voice_detection"
                }
            
            # T√¨m ƒëo·∫°n voice ƒë·∫ßu ti√™n ph√π h·ª£p
            first_voice = self._find_optimal_voice_segment(voice_segments)
            if not first_voice:
                return {
                    "success": False,
                    "error": "Kh√¥ng t√¨m th·∫•y ƒëo·∫°n voice ph√π h·ª£p",
                    "step": "voice_selection"
                }
            
            logger.info(f"üéØ T√¨m th·∫•y ƒëo·∫°n voice: {first_voice['start']:.2f}s - {first_voice['end']:.2f}s")

            # B∆∞·ªõc 2: C·∫Øt 30s t·ª´ 15s ƒë·∫øn 45s c·ªßa file karaoke
            logger.info("‚úÇÔ∏è B∆∞·ªõc 2: C·∫Øt 30s (15s‚Äì45s) t·ª´ file karaoke...")
            import librosa, soundfile as sf
            base_stem = os.path.splitext(os.path.basename(karaoke_file))[0]
            start_t = 15.0
            duration = 30.0
            end_t = start_t + duration
            audio, sr = librosa.load(karaoke_file, sr=None, mono=True)
            start_sample = int(start_t * sr)
            end_sample = int(end_t * sr)
            if start_sample >= len(audio):
                return {
                    "success": False,
                    "error": "Karaoke ng·∫Øn h∆°n 15s",
                    "step": "audio_slicing"
                }
            slice_audio = audio[start_sample:min(end_sample, len(audio))]
            sliced_path = os.path.join(output_dir, f"{base_stem}_slice_{int(start_t)}s_{int(end_t)}s.wav")
            sf.write(sliced_path, slice_audio, sr)

            # B∆∞·ªõc 3: C·∫Øt beat t·ª´ 15s ƒë·∫øn 45s (c√πng kho·∫£ng v·ªõi karaoke) ƒë·ªÉ ƒë·∫£m b·∫£o key ch√≠nh x√°c
            logger.info("‚úÇÔ∏è B∆∞·ªõc 3: C·∫Øt beat t·ª´ 15s‚Äì45s (c√πng kho·∫£ng v·ªõi karaoke)...")
            beat_audio, beat_sr = librosa.load(beat_file, sr=None, mono=True)
            beat_start_t = start_t  # C√πng th·ªùi ƒëi·ªÉm v·ªõi karaoke (15s)
            beat_end_t = end_t      # C√πng th·ªùi ƒëi·ªÉm v·ªõi karaoke (45s)
            beat_start_sample = int(beat_start_t * beat_sr)
            beat_end_sample = int(beat_end_t * beat_sr)
            if beat_start_sample >= len(beat_audio):
                return {
                    "success": False,
                    "error": "Beat ng·∫Øn h∆°n 15s",
                    "step": "beat_slicing"
                }
            beat_slice = beat_audio[beat_start_sample:min(beat_end_sample, len(beat_audio))]
            beat_sliced_path = os.path.join(output_dir, f"{base_stem}_beat_slice_{int(beat_start_t)}s_{int(beat_end_t)}s.wav")
            sf.write(beat_sliced_path, beat_slice, beat_sr)

            # B∆∞·ªõc 4: AI Audio Separator - T√°ch gi·ªçng t·ª´ file ƒë√£ c·∫Øt 30s
            logger.info("üé§ B∆∞·ªõc 4: T√°ch gi·ªçng h√°t t·ª´ ƒëo·∫°n 30s ƒë√£ c·∫Øt...")
            vocals_file = self.audio_processor.separate_vocals(sliced_path)
            
            if not vocals_file or not os.path.exists(vocals_file):
                return {
                    "success": False,
                    "error": "L·ªói t√°ch gi·ªçng h√°t",
                    "step": "vocal_separation"
                }
            
            # Copy/export vocals 30s v·ªÅ output_dir v·ªõi t√™n d·ªÖ nh·∫≠n bi·∫øt
            vocals_ext = os.path.splitext(vocals_file)[1]
            vocals_export = os.path.join(output_dir, f"{base_stem}_slice_vocals{vocals_ext}")
            try:
                import shutil
                if vocals_file != vocals_export:
                    shutil.copy2(vocals_file, vocals_export)
            except Exception:
                vocals_export = vocals_file

            logger.info(f"‚úÖ ƒê√£ t√°ch gi·ªçng h√°t (20s): {vocals_export}")
            
            # B∆∞·ªõc 3: Key Detection - Detect key t·ª´ file beat g·ªëc (kh√¥ng c·∫Øt)
            logger.info("üéπ B∆∞·ªõc 3: Ph√°t hi·ªán ph√≠m √¢m nh·∫°c...")
            
            # Key detection cho vocals (file 20s ƒë√£ t√°ch)
            vocals_key = self.key_detector.detect_key(vocals_export, "vocals")
            
            # Th·ª≠ nhi·ªÅu ph∆∞∆°ng ph√°p detect key cho beat (file g·ªëc)
            beat_key = None
            beat_methods = ['beat', 'instrumental', 'vocals']  # Th·ª≠ c√°c audio_type kh√°c nhau
            
            for method in beat_methods:
                try:
                    temp_beat_key = self.key_detector.detect_key(beat_file, method)
                    if temp_beat_key and 'key' in temp_beat_key:
                        beat_key = temp_beat_key
                        logger.info(f"‚úÖ Beat key detected v·ªõi method '{method}': {beat_key['key']}")
                        break
                except Exception as e:
                    logger.warning(f"Method '{method}' failed: {e}")
                    continue
            
            logger.info(f"üéµ Beat key: {beat_key['key']} {beat_key['scale']} (confidence: {beat_key['confidence']:.3f})")
            logger.info(f"üé§ Vocals key: {vocals_key['key']} {vocals_key['scale']} (confidence: {vocals_key['confidence']:.3f})")
            
            # B∆∞·ªõc 4: Key Comparison - So s√°nh key
            logger.info("üîç B∆∞·ªõc 4: So s√°nh ph√≠m √¢m nh·∫°c...")
            key_comparison = self.key_detector.compare_keys(beat_key, vocals_key)
            
            logger.info(f"üìä Key similarity score: {key_comparison['score']}/100")
            
            # B∆∞·ªõc 5: Scoring - T√≠nh ƒëi·ªÉm
            logger.info("üìä B∆∞·ªõc 5: T√≠nh ƒëi·ªÉm t·ªïng th·ªÉ...")
            scoring_result = self.scoring_system.calculate_overall_score(
                karaoke_file, beat_file, vocals_export
            )
            
            logger.info(f"üèÜ Overall score: {scoring_result['overall_score']}/100")
            
            # T·∫°o k·∫øt qu·∫£ ho√†n ch·ªânh
            result = {
                "success": True,
                "input_files": {
                    "karaoke_file": karaoke_file,
                    "beat_file": beat_file
                },
                "processed_files": {
                    "karaoke_file": karaoke_file,
                    "sliced_karaoke": sliced_path,
                    "vocals_file": vocals_export
                },
                "voice_detection": {
                    "voice_segments": voice_segments,
                    "selected_voice": first_voice,
                    "slice_start_time": start_t
                },
                "key_detection": {
                    "beat_key": beat_key,
                    "vocals_key": vocals_key,
                    "key_comparison": key_comparison
                },
                "scoring": scoring_result,
                "processing_time": {
                    "voice_detection_time": "N/A",  # C√≥ th·ªÉ th√™m timing
                    "vocal_separation_time": "N/A",
                    "key_detection_time": "N/A",
                    "total_time": "N/A"
                }
            }
            
            logger.info("üéâ Ho√†n th√†nh x·ª≠ l√Ω karaoke v·ªõi workflow t·ªëi ∆∞u h√≥a!")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói trong qu√° tr√¨nh x·ª≠ l√Ω: {e}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "error": str(e),
                "step": "unknown"
            }
    
    def _find_optimal_voice_segment(self, voice_segments: list) -> Optional[Dict]:
        """T√¨m ƒëo·∫°n voice t·ªëi ∆∞u ƒë·ªÉ c·∫Øt"""
        try:
            for segment in voice_segments:
                duration = segment["end"] - segment["start"]
                
                # Ki·ªÉm tra th·ªùi l∆∞·ª£ng t·ªëi thi·ªÉu
                if duration >= self.min_voice_duration:
                    return {
                        "start": segment["start"],
                        "end": segment["end"],
                        "confidence": segment["confidence"]
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói t√¨m optimal voice segment: {e}")
            return None
    
    # C·∫Øt audio kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong workflow full audio
    
    def get_processing_summary(self, result: Dict) -> str:
        """T·∫°o t√≥m t·∫Øt k·∫øt qu·∫£ x·ª≠ l√Ω"""
        if not result["success"]:
            return f"‚ùå X·ª≠ l√Ω th·∫•t b·∫°i: {result['error']} (B∆∞·ªõc: {result['step']})"
        
        summary = f"""
üéâ X·ª¨ L√ù TH√ÄNH C√îNG!

üìÅ Files ƒë√£ x·ª≠ l√Ω:
   ‚Ä¢ Karaoke slice: {os.path.basename(result['processed_files']['sliced_karaoke'])}
   ‚Ä¢ Vocals file: {os.path.basename(result['processed_files']['vocals_file'])}

üé§ Voice Detection:
   ‚Ä¢ T√¨m th·∫•y {len(result['voice_detection']['voice_segments'])} ƒëo·∫°n voice
   ‚Ä¢ Ch·ªçn ƒëo·∫°n: {result['voice_detection']['selected_voice']['start']:.2f}s - {result['voice_detection']['selected_voice']['end']:.2f}s
   ‚Ä¢ C·∫Øt t·ª´: {result['voice_detection']['slice_start_time']:.2f}s (20s)

üéπ Key Detection:
   ‚Ä¢ Beat key: {result['key_detection']['beat_key']['key']} {result['key_detection']['beat_key']['scale']} (confidence: {result['key_detection']['beat_key']['confidence']:.3f})
   ‚Ä¢ Vocals key: {result['key_detection']['vocals_key']['key']} {result['key_detection']['vocals_key']['scale']} (confidence: {result['key_detection']['vocals_key']['confidence']:.3f})
   ‚Ä¢ Key similarity: {result['key_detection']['key_comparison']['score']}/100

üìä Scoring:
   ‚Ä¢ Overall score: {result['scoring']['overall_score']}/100
   ‚Ä¢ Key accuracy: {result['scoring']['detailed_scores']['key_accuracy']:.1f}/100
   ‚Ä¢ Pitch accuracy: {result['scoring']['detailed_scores']['pitch_accuracy']:.1f}/100
   ‚Ä¢ Rhythm accuracy: {result['scoring']['detailed_scores']['rhythm_accuracy']:.1f}/100
        """
        
        return summary.strip()
    
    def batch_process_optimized(self, 
                               file_pairs: list, 
                               output_dir: str = None) -> list:
        """
        X·ª≠ l√Ω batch nhi·ªÅu c·∫∑p file v·ªõi workflow t·ªëi ∆∞u h√≥a
        
        Args:
            file_pairs: List of tuples [(karaoke_file, beat_file), ...]
            output_dir: Th∆∞ m·ª•c output
            
        Returns:
            list: Danh s√°ch k·∫øt qu·∫£ x·ª≠ l√Ω
        """
        results = []
        
        logger.info(f"üé§ B·∫Øt ƒë·∫ßu batch processing {len(file_pairs)} file pairs...")
        
        for i, (karaoke_file, beat_file) in enumerate(file_pairs, 1):
            logger.info(f"üìÅ Processing pair {i}/{len(file_pairs)}: {Path(karaoke_file).name}")
            
            result = self.process_karaoke_optimized(karaoke_file, beat_file, output_dir)
            results.append(result)
            
            if result["success"]:
                logger.info(f"‚úÖ Pair {i} processed successfully")
            else:
                logger.warning(f"‚ö†Ô∏è Pair {i} failed: {result.get('error', 'Unknown error')}")
        
        # Th·ªëng k√™
        successful = sum(1 for r in results if r["success"])
        logger.info(f"üìä Batch processing completed: {successful}/{len(file_pairs)} pairs successful")
        
        return results
